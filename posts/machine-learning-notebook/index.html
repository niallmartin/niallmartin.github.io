<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="indicium artificium">
    <meta name="description" content="Niall Martin&#39;s personal website">
    <meta name="keywords" content="blog,developer,personal,data science,machine learning,ML,AI,python,keras,tensorflow">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Machine Learning Notebook"/>
<meta name="twitter:description" content="An ongoing list of ML notes and commands that I find useful."/>

    <meta property="og:title" content="Machine Learning Notebook" />
<meta property="og:description" content="An ongoing list of ML notes and commands that I find useful." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://niallmartin.io/posts/machine-learning-notebook/" />
<meta property="article:published_time" content="2020-02-01T18:00:32+00:00" />
<meta property="article:modified_time" content="2020-02-01T18:00:32+00:00" />


    
      <base href="https://niallmartin.io/posts/machine-learning-notebook/">
    
    <title>
  Machine Learning Notebook · Niall Martin
</title>

    
      <link rel="canonical" href="https://niallmartin.io/posts/machine-learning-notebook/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://niallmartin.io/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="https://niallmartin.io/custom.css" />
    

    

    

    <link rel="icon" type="image/png" href="https://niallmartin.io/images/logo.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://niallmartin.io/images/logo.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.62.2" />
  </head>

  
  
  <body class="colorscheme-light">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://niallmartin.io/">
      Niall Martin
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://niallmartin.io/about/">ABOUT</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://niallmartin.io/posts/">BLOG</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://vectordatascience.com">CONSULTING</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://niallmartin.io/quotes/">QUOTES</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Machine Learning Notebook</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2020-02-01T18:00:32Z'>
                February 1, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              8 minutes read
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://niallmartin.io/categories/resources/">Resources</a></div>

          
        </div>
      </header>

      <div>
        <h1 id="machine-learning-notebook">Machine Learning Notebook</h1>
<p>I have a terrible memory. But thing that I find particularly helpful when trying to remember conepts is an ongoing journal of terms. I've traditionally use a moleskin for this task, but have decided to switch to using this blog.</p>
<p>In that spirit, what follows is a live, ever evolving list of ML concepts, links and papers.</p>
<h3 id="optimisers">Optimisers</h3>
<p>Term used to describe algorithms that minimise (or maximise) the objective function. Optimisers tie together the loss function and model parameters by updating the model in response to the output of the loss function. In simpler terms, optimizers shape and mold your model into its most accurate possible form by futzing with the weights. The loss function is the guide to the terrain, telling the optimiser when it’s moving in the right or wrong direction.</p>
<ul>
<li>
<p>Types of optimisers:</p>
<ul>
<li><strong>Batch Gradient Descent:</strong> The grandaddy of all optimisers, computes the gradient of the cost function w.r.t. to the parameters for the <em>entire</em> training dataset. Batch gradient descent is guaranteed to converge to the global minimum for convex error surfaces and to a local minimum for non-convex surfaces. Link <a href="https://ruder.io/optimizing-gradient-descent/index.html#batchgradientdescent">here</a>.</li>
<li><strong>Stochastic Gradient Descent:</strong> Instead of calculating the gradients for all of your training examples on every pass of gradient descent, it’s sometimes more efficient to only use a subset of the training examples each time. <a href="http://ufldl.stanford.edu/tutorial/supervised/OptimizationStochasticGradientDescent/">Stochastic gradient descent</a> is an implementation that either uses batches of examples at a time or random examples on each pass.</li>
<li><strong>Adagrad:</strong> Adagrad adapts the learning rate specifically to individual features. That means that some of the weights in your dataset will have different learning rates than others. This works really well for sparse datasets where a lot of input examples are missing. Adagrad has a major issue though: the adaptive learning rate tends to get really small over time. Some other optimisers below seek to eliminate this problem.
<ul>
<li>One of Adagrad's main benefits is that it eliminates the need to manually tune the learning rate. Most implementations use a default value of 0.01 and leave it at that.</li>
<li>Adagrad's main weakness is its accumulation of the squared gradients in the denominator: Since every added term is positive, the accumulated sum keeps growing during training. This in turn causes the learning rate to shrink and eventually become infinitesimally small, at which point the algorithm is no longer able to acquire additional knowledge.</li>
<li><strong>Adadelta:</strong> Adadelta aims to resolved the weakness of Adagrad by reducing its aggressive, monotonically decreasing learning rate. Instead of accumulating all past squared gradients, Adadelta restricts the window of accumulated past gradients to some fixed size, w.</li>
<li><strong>RMSProp:</strong> RMSprop is an unpublished, adaptive learning rate method proposed by Geoff Hinton in <a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">Lecture 6e of his Coursera Class</a>. RMSprop was also developed to resolve Adagrad's radically diminishing learning rates. RMSprop is good, fast and very popular optimiser. Andrej Karpathy’s “<a href="https://medium.com/@karpathy/a-peek-at-trends-in-machine-learning-ab8a1085a106">A Peek at Trends in Machine Learning</a>” shows that it’s one of the most popular optimization algorithms used in deep learning, its popularity is only surpassed by Adam[5].</li>
</ul>
</li>
<li><strong>ADAM:</strong> Adaptive Moment Estimation (Adam) is another method that computes adaptive learning rates for each parameter. In addition to storing an exponentially decaying average of past squared gradients like RMSprop, Adam also keeps an exponentially decaying average of past gradients similar to momentum. Whereas momentum can be seen as a ball running down a slope, Adam behaves like a heavy ball with friction, which thus prefers flat minima in the error surface. More detailed discussion is available <a href="https://ruder.io/optimizing-gradient-descent/index.html#adam">here</a>.</li>
</ul>
</li>
</ul>
<h3 id="momentum">Momentum</h3>
<p>SGD has trouble navigating ravines, i.e. areas where the surface curves much more steeply in one dimension than in another, which are common around local optima. In these scenarios, SGD oscillates across the slopes of the ravine while only making hesitant progress along the bottom towards the local optimum. Momentum is a method that helps accelerate SGD in the relevant direction and dampens oscillations. It does this by adding a fraction of the update vector of the past time step to the current update vector. Essentially, when using momentum, we push a ball down a hill. The ball accumulates momentum as it rolls downhill, becoming faster and faster on the way (until it reaches its terminal velocity if there is air resistance, i.e. The same thing happens to our parameter updates: The momentum term increases for dimensions whose gradients point in the same directions and reduces updates for dimensions whose gradients change directions. As a result, we gain faster convergence and reduced oscillation.</p>
<figure class="centered">
    <img src="https://niallmartin.io/images/notebook_ml/contours_evaluation_optimizers.gif"
         alt="optimisers_gradient_path" height="250"/> 
</figure>

<h3 id="batch-normalisation">Batch Normalisation</h3>
<p>To facilitate learning, we typically normalize the initial values of our parameters by initializing them with zero mean and unit variance. As training progresses and we update parameters to different extents, we lose this normalization, which slows down training and amplifies changes as the network becomes deeper. Batch normalization <a href="https://arxiv.org/abs/1502.03167">Ref</a> re-establishes these normalizations for every mini-batch and changes are back-propagated through the operation as well. By making normalization part of the model architecture, we are able to use higher learning rates and pay less attention to the initialization parameters. Batch normalization additionally acts as a regularizer, reducing (and sometimes even eliminating) the need for Dropout.</p>
<h3 id="seq2seq">Seq2Seq</h3>
<p>Seq2Seq models are particularly good at translation, where the sequence of words from one language is transformed into a sequence of different words in another language. A popular choice for this type of model is Long-Short-Term-Memory (LSTM)-based models. With sequence-dependent data, the LSTM modules can giving meaning to the sequence while remembering (or forgetting) the parts it finds important (or unimportant). Sentences, for example, are sequence-dependent since the order of the words is crucial for understanding the sentence. LSTM are a natural choice for this type of data.
Seq2Seq models consist of an Encoder and a Decoder. The Encoder takes the input sequence and maps it into a higher dimensional space (n-dimensional vector). That abstract vector is fed into the Decoder which turns it into an output sequence. The output sequence can be in another language, symbols, a copy of the input, etc.</p>
<p>Imagine the Encoder and Decoder as human translators who can speak only two languages. Their first language is their mother tongue, which differs between both of them (e.g. German and French) and their second language an imaginary one they have in common. To translate German into French, the Encoder converts the German sentence into the other language it knows, namely the imaginary language. Since the Decoder is able to read that imaginary language, it can now translates from that language into French. Together, the model (consisting of Encoder and Decoder) can translate German into French!</p>
<ul>
<li>Read <a href="https://medium.com/inside-machine-learning/what-is-a-transformer-d07dd1fbec04">this blog</a> for more details.</li>
<li>For a more scientific approach than the one provided, read about different attention-based approaches for Sequence-to-Sequence models in (this great paper)[https://nlp.stanford.edu/pubs/emnlp15_attn.pdf] called ‘Effective Approaches to Attention-based Neural Machine Translation’.</li>
</ul>
<h3 id="attention">Attention</h3>
<p>The attention-mechanism looks at an input sequence and decides at each step which other parts of the sequence are important. It sounds abstract, but let me clarify with an easy example: When reading this text, you always focus on the word you read but at the same time your mind still holds the important keywords of the text in memory in order to provide context.</p>
<p>An attention-mechanism works similarly for a given sequence. For the example with a human Encoder and Decoder (as described in the Seq2Seq section), imagine that instead of only writing down the translation of the sentence in the imaginary language, the Encoder also writes down keywords that are important to the semantics of the sentence, and gives them to the Decoder in addition to the regular translation. Those new keywords make the translation much easier for the Decoder because it knows what parts of the sentence are important and which key terms give the sentence context.
In other words, for each input that the LSTM (Encoder) reads, the attention-mechanism takes into account several other inputs at the same time and decides which ones are important by attributing different weights to those inputs.</p>
<ol>
<li>The original <a href="https://arxiv.org/abs/1706.03762">Attention is all you need</a> paper.</li>
<li>To learn more about attention, read <a href="https://pathmind.com/wiki/attention-mechanism-memory-network">this article</a>.</li>
</ol>
<h3 id="transformer">Transformer</h3>
<p>The paper ‘Attention Is All You Need’ introduces a novel architecture called Transformer. As the title indicates, it uses the attention-mechanism we saw earlier. Like LSTM, Transformer is an architecture for transforming one sequence into another one with the help of two parts (Encoder and Decoder), but it differs from the previously described/existing sequence-to-sequence models because it does not imply any Recurrent Networks (GRU, LSTM, etc.).</p>
<figure class="centered">
    <img src="https://niallmartin.io/images/notebook_ml/transformer.png"
         alt="optimisers_gradient_path" height="500"/> 
</figure>

<p>The Transformer consists of two main components: a set of encoders chained together and a set of decoders chained together. The are used in the following way:</p>
<ul>
<li>The function of each encoder is to process its input vectors to generate what are known as encodings, which contain information about the parts of the inputs which are relevant to each other. It passes its set of generated encodings to the next encoder as inputs.</li>
<li>Each decoder does the opposite, taking all the encodings and processing them, using their incorporated contextual information to generate an output sequence.</li>
<li>To achieve this, each encoder and decoder makes use of an attention mechanism, which for each input, weighs the relevance of every input and draws information from them accordingly when producing the output. Each decoder also has an additional attention mechanism which draws information from the outputs of previous decoders, before the decoder draws information from the encodings. Both the encoders and decoders have a final feed-forward neural network for additional processing of the outputs, and also contain residual connections and layer normalisation steps.</li>
</ul>
<p>Links:</p>
<ul>
<li>See <a href="http://jalammar.github.io/illustrated-transformer/">this illustrative</a> description of the transformer for more details.</li>
<li><a href="https://medium.com/inside-machine-learning/what-is-a-transformer-d07dd1fbec04">Here</a> is an excellent article giving an overview of what a transformer is.</li>
</ul>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "niallmartin" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css" integrity="sha384-dbVIfZGuN1Yq7/1Ocstc1lUEm+AT+/rCkibIcC/OmWo5f0EA48Vf8CytHzGrSwbQ" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js" integrity="sha384-2BKqo+exmr9su6dir+qCw08N2ZKRucY4PrGQPPWU1A7FtlCGjmEGFqXCv5nyM5Ij" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );">
  </script>
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
      <p>data science & machine learning</p>
    
    
      
        © 2020
      
       indicium artificium 
    
    
    
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-48181177-3', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
